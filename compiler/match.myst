-- TODO: Temporary
let chooseCol alts = 0

let addOpts col options alt =  -- TODO: Consider renaming
    let target = alt.targets !! col

    -- Add alt to the option iff it is a superset
    let addIfSuperset option =
        if isSupersetOf target option.cond
        then option#{ alternatives: x.alternatives ++ [alt] }
        else option

    -- Add new option iff no previous option is a superset
    let appendIfSubset options =
        if some (fn x -> isSupersetOf x.cond target) options
        then options
        else options ++ [{ alternatives: [alt], cond: target }]

    options |> map addIfSuperset %
            |> appendIfSubset %

let getOpts alts col =
    fold (addOpts col % %) [] alts


let wildcardCond ids opt col els =
    let [nIds, nAlts] = successIdsAlts ids opt.alternatives col
    toSwitch nIds nAlts

let literalCond ids opt col els =
    let [nIds, nAlts] = successIdsAlts ids opt.alternatives col
    Syntax.If
        (Syntax.Operation 'eq' id opt.cond)
        Arr#[ toSwitch nIds nAlts ]
        [ els ]

let listMatchCond ids opt col els =
    let [nIds, nAlts] = successIdsAlts ids opt.alternatives col


-- Generate the conditional
let mkConditional ids options col =
    let id = ids !! col

    let fail = Syntax.Invocation (Syntax.Identifier 'error') Arr#[]

    let singleCond els let =
        option cond = option.cond
        let id = ids
        -- Different based on the type of option.cond
    foldr singleCond fail options

-- Transform a set of identifiers & alternatives into a switch
let toSwitch ids alts =
    if length ids == 0
    then Syntax.Block (alternatives !! 0).body
    else
      let col = chooseCol alts   -- Get the column to work on
      let options = getOpts alts col -- Get the options
      mkConditional ids options col
